{"kind":"code","props":{"deps":{"Hex":{"$jig":"727e7b423b7ee40c0b5be87fba7fa5673ea2d20a74259040a7295d9c32a90011_o1"},"Tx":{"$jig":"_o1"}},"location":"_o2","nonce":2,"origin":"312985bd960ae4c59856b3089b04017ede66506ea181333eec7c9bb88b11c490_o1","owner":"1PytriYokKN3GpKw84L4vvrGBwUvTYzCpx","satoshis":0},"src":"function txo (rawtx) {\n  const ret = { }\n\n  function chunks (script) {\n    const b = Hex.stringToBytes(script)\n    let i = 0\n\n    function u8 () { return b[i++] }\n    function u16 () { return u8() + u8() * 256 }\n    function u32 () { return u16() + u16() * 256 * 256 }\n    function buf (n) { const h = Hex.bytesToString(b.slice(i, i + n)); i += n; return h }\n\n    const OP_PUSHDATA1 = 0x4c\n    const OP_PUSHDATA2 = 0x4d\n    const OP_PUSHDATA4 = 0x4e\n\n    const chunks = []\n    while (i < b.length) {\n      const opcodenum = u8()\n      if (opcodenum > 0 && opcodenum < OP_PUSHDATA1) {\n        chunks.push({ buf: buf(opcodenum), len: opcodenum, opcodenum })\n      } else if (opcodenum === OP_PUSHDATA1) {\n        const len = u8()\n        chunks.push({ buf: buf(len), len, opcodenum })\n      } else if (opcodenum === OP_PUSHDATA2) {\n        const len = u16()\n        chunks.push({ buf: buf(len), len, opcodenum })\n      } else if (opcodenum === OP_PUSHDATA4) {\n        const len = u32()\n        chunks.push({ buf: buf(len), len, opcodenum })\n      } else {\n        chunks.push({ opcodenum })\n      }\n    }\n    return chunks\n  }\n\n  // https://stackoverflow.com/questions/23190056/hex-to-base64-converter-for-javascript\n  function bytesToBase64 (arr) {\n    const abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' // base64 alphabet\n    const bin = n => n.toString(2).padStart(8, 0) // convert num to 8-bit binary string\n    const l = arr.length\n    let result = ''\n    for (let i = 0; i <= (l - 1) / 3; i++) {\n      const c1 = i * 3 + 1 >= l // case when \"=\" is on end\n      const c2 = i * 3 + 2 >= l // case when \"=\" is on end\n      const chunk = bin(arr[3 * i]) + bin(c1 ? 0 : arr[3 * i + 1]) + bin(c2 ? 0 : arr[3 * i + 2])\n      const r = chunk.match(/.{1,6}/g).map((x, j) => j === 3 && c2 ? '=' : (j === 2 && c1 ? '=' : abc[+('0b' + x)]))\n      result += r.join('')\n    }\n    return result\n  }\n\n  function xput (script, output) {\n    const ret = { }\n    chunks(script).forEach((c, n) => {\n      if (c.buf) {\n        ret['b' + n] = bytesToBase64(Hex.stringToBytes(c.buf))\n        const enc = c.buf.replace(/[0-9a-f]{2}/g, '%$&')\n        if (output) try { ret['s' + n] = decodeURIComponent(enc) } catch (e) { }\n        if (output) ret['h' + n] = c.buf\n      } else {\n        ret['b' + n] = { op: c.opcodenum }\n      }\n    })\n    return ret\n  }\n\n  function input (txin, i) {\n    const ret = xput(txin.script)\n    ret.e = { h: txin.prevTxId, i: txin.outputIndex }\n    ret.i = i\n    ret.seq = txin.sequenceNumber\n    return ret\n  }\n\n  function output (txout, i) {\n    const ret = xput(txout.script, true)\n    ret.e = { v: txout.satoshis, i }\n    ret.i = i\n    return ret\n  }\n\n  const tx = new Tx(rawtx)\n  ret.in = tx.inputs.map(input)\n  ret.out = tx.outputs.map(output)\n  ret.lock = tx.nLockTime\n  return ret\n}","version":"04"}